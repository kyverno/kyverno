package api

import (
	"fmt"
	"time"

	kyvernov1 "github.com/kyverno/kyverno/api/kyverno/v1"
	kyvernov2alpha1 "github.com/kyverno/kyverno/api/kyverno/v2alpha1"
	pssutils "github.com/kyverno/kyverno/pkg/pss/utils"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/pod-security-admission/api"
)

// PodSecurityChecks details about pod securty checks
type PodSecurityChecks struct {
	// Level is the pod security level
	Level api.Level
	// Version is the pod security version
	Version string
	// Checks contains check result details
	Checks []pssutils.PSSCheckResult
}

// RuleResponse details for each rule application
type RuleResponse struct {
	// Name is the rule name specified in policy
	Name string
	// Type is the rule type (Mutation,Generation,Validation) for Kyverno Policy
	Type RuleType
	// Message is the message response from the rule application
	Message string
	// Patches are JSON patches, for mutation rules
	Patches [][]byte
	// GeneratedResource is the generated by the generate rules of a policy
	GeneratedResource unstructured.Unstructured
	// Status rule status
	Status RuleStatus
	// Stats contains rule statistics
	Stats ExecutionStats
	// PatchedTarget is the patched resource for mutate.targets
	PatchedTarget *unstructured.Unstructured
	// PatchedTargetSubresourceName is the name of the subresource which is patched, empty if the resource patched is not a subresource.
	PatchedTargetSubresourceName string
	// PatchedTargetParentResourceGVR is the GVR of the parent resource of the PatchedTarget. This is only populated when PatchedTarget is a subresource.
	PatchedTargetParentResourceGVR metav1.GroupVersionResource
	// PodSecurityChecks contains pod security checks (only if this is a pod security rule)
	PodSecurityChecks *PodSecurityChecks
	// Exception is the exception applied (if any)
	Exception *kyvernov2alpha1.PolicyException
}

func NewRuleResponse(rule kyvernov1.Rule, ruleType RuleType, msg string, status RuleStatus) *RuleResponse {
	return &RuleResponse{
		Name:    rule.Name,
		Type:    ruleType,
		Message: msg,
		Status:  status,
	}
}

func RuleError(rule kyvernov1.Rule, ruleType RuleType, msg string, err error) *RuleResponse {
	if err != nil {
		return NewRuleResponse(rule, ruleType, fmt.Sprintf("%s: %s", msg, err.Error()), RuleStatusError)
	}
	return NewRuleResponse(rule, ruleType, msg, RuleStatusError)
}

func RuleSkip(rule kyvernov1.Rule, ruleType RuleType, msg string) *RuleResponse {
	return NewRuleResponse(rule, ruleType, msg, RuleStatusSkip)
}

func RulePass(rule kyvernov1.Rule, ruleType RuleType, msg string) *RuleResponse {
	return NewRuleResponse(rule, ruleType, msg, RuleStatusPass)
}

func RuleFail(rule kyvernov1.Rule, ruleType RuleType, msg string) *RuleResponse {
	return NewRuleResponse(rule, ruleType, msg, RuleStatusFail)
}

// func (r RuleResponse) DoneNow() RuleResponse {
// 	return r.Done(time.Now())
// }

func (r RuleResponse) WithException(exception *kyvernov2alpha1.PolicyException) *RuleResponse {
	r.Exception = exception
	return &r
}

func (r RuleResponse) WithPodSecurityChecks(checks PodSecurityChecks) *RuleResponse {
	r.PodSecurityChecks = &checks
	return &r
}

func (r RuleResponse) WithStats(startTime, endTime time.Time) RuleResponse {
	r.Stats = NewExecutionStats(startTime)
	r.Stats.Done(endTime)
	return r
}

// func (r RuleResponse) Done(timestamp time.Time) RuleResponse {
// 	r.Stats.Done(timestamp)
// 	return r
// }

// HasStatus checks if rule status is in a given list
func (r RuleResponse) HasStatus(status ...RuleStatus) bool {
	for _, s := range status {
		if r.Status == s {
			return true
		}
	}
	return false
}

// String implements Stringer interface
func (r RuleResponse) String() string {
	return fmt.Sprintf("rule %s (%s): %v", r.Name, r.Type, r.Message)
}
