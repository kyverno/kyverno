package exception

import (
	"crypto/sha256"
	"fmt"

	kyvernov1 "github.com/kyverno/kyverno/api/kyverno/v1"
	kyvernov2 "github.com/kyverno/kyverno/api/kyverno/v2"
	kyvernov2beta1 "github.com/kyverno/kyverno/api/kyverno/v2beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	// LabelAutoGenerated marks a PolicyException as auto-generated by the exception controller.
	LabelAutoGenerated = "kyverno.io/auto-generated-exception"
	// LabelSourcePolicy records which policy triggered the auto-generated exception.
	LabelSourcePolicy = "kyverno.io/source-policy"
)

// ownerInfo holds resolved owner metadata for building exceptions.
type ownerInfo struct {
	kind      string
	name      string
	namespace string
}

// buildPolicyException constructs a PolicyException resource that exempts the given
// owner resource from the specified policy and rules.
func buildPolicyException(
	policyName string,
	isClusterPolicy bool,
	ruleNames []string,
	owner ownerInfo,
) *kyvernov2.PolicyException {
	exceptionName := generateExceptionName(policyName, owner.kind, owner.name)

	polexPolicyName := policyName
	if !isClusterPolicy {
		// For namespaced policies, the exception references <namespace>/<name>
		// The policyName passed in should already be in that format when needed.
	}

	return &kyvernov2.PolicyException{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "kyverno.io/v2",
			Kind:       "PolicyException",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      exceptionName,
			Namespace: owner.namespace,
			Labels: map[string]string{
				LabelAutoGenerated: "true",
				LabelSourcePolicy:  policyName,
			},
		},
		Spec: kyvernov2.PolicyExceptionSpec{
			Match: kyvernov2beta1.MatchResources{
				Any: kyvernov1.ResourceFilters{
					{
						ResourceDescription: kyvernov1.ResourceDescription{
							Kinds:      []string{owner.kind},
							Names:      []string{owner.name},
							Namespaces: namespacesForMatch(owner.namespace),
						},
					},
				},
			},
			Exceptions: []kyvernov2.Exception{
				{
					PolicyName: polexPolicyName,
					RuleNames:  ruleNames,
				},
			},
		},
	}
}

// namespacesForMatch returns a namespace filter slice.
// For cluster-scoped resources (empty namespace), returns nil.
func namespacesForMatch(namespace string) []string {
	if namespace == "" {
		return nil
	}
	return []string{namespace}
}

// generateExceptionName produces a deterministic, unique name for an auto-generated
// PolicyException based on the policy name and the owner resource.
// The name is truncated to comply with the 253-character Kubernetes name limit.
func generateExceptionName(policyName, ownerKind, ownerName string) string {
	base := fmt.Sprintf("autogen-exc-%s-%s-%s", policyName, ownerKind, ownerName)
	if len(base) <= 253 {
		return sanitizeName(base)
	}
	// Use a hash suffix for long names
	hash := fmt.Sprintf("%x", sha256.Sum256([]byte(base)))[:8]
	truncated := base[:253-9] // leave room for "-" + 8 char hash
	return sanitizeName(truncated + "-" + hash)
}

// sanitizeName replaces characters not allowed in Kubernetes resource names.
func sanitizeName(name string) string {
	result := make([]byte, len(name))
	for i := 0; i < len(name); i++ {
		c := name[i]
		if (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '-' || c == '.' {
			result[i] = c
		} else if c >= 'A' && c <= 'Z' {
			result[i] = c + 32 // lowercase
		} else {
			result[i] = '-'
		}
	}
	// Ensure name starts with alphanumeric
	if len(result) > 0 && !(result[0] >= 'a' && result[0] <= 'z') && !(result[0] >= '0' && result[0] <= '9') {
		result[0] = 'x'
	}
	return string(result)
}
