package exception

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func Test_buildPolicyException_ClusterPolicy(t *testing.T) {
	polex := buildPolicyException(
		"require-labels",
		true,
		[]string{"check-for-labels"},
		ownerInfo{kind: "Deployment", name: "my-app", namespace: "default"},
	)

	assert.Equal(t, "default", polex.Namespace)
	assert.Equal(t, "true", polex.Labels[LabelAutoGenerated])
	assert.Equal(t, "require-labels", polex.Labels[LabelSourcePolicy])
	assert.Len(t, polex.Spec.Match.Any, 1)
	assert.Equal(t, []string{"Deployment"}, polex.Spec.Match.Any[0].ResourceDescription.Kinds)
	assert.Equal(t, []string{"my-app"}, polex.Spec.Match.Any[0].ResourceDescription.Names)
	assert.Equal(t, []string{"default"}, polex.Spec.Match.Any[0].ResourceDescription.Namespaces)
	assert.Len(t, polex.Spec.Exceptions, 1)
	assert.Equal(t, "require-labels", polex.Spec.Exceptions[0].PolicyName)
	assert.Equal(t, []string{"check-for-labels"}, polex.Spec.Exceptions[0].RuleNames)
}

func Test_buildPolicyException_NamespacedPolicy(t *testing.T) {
	polex := buildPolicyException(
		"default/require-labels",
		false,
		[]string{"check-for-labels", "check-for-annotations"},
		ownerInfo{kind: "StatefulSet", name: "my-db", namespace: "default"},
	)

	assert.Equal(t, "default", polex.Namespace)
	assert.Equal(t, "default/require-labels", polex.Spec.Exceptions[0].PolicyName)
	assert.Len(t, polex.Spec.Exceptions[0].RuleNames, 2)
}

func Test_buildPolicyException_ClusterScopedResource(t *testing.T) {
	polex := buildPolicyException(
		"require-labels",
		true,
		[]string{"check-labels"},
		ownerInfo{kind: "Namespace", name: "test-ns", namespace: ""},
	)

	assert.Equal(t, "", polex.Namespace)
	assert.Nil(t, polex.Spec.Match.Any[0].ResourceDescription.Namespaces)
}

func Test_buildPolicyException_MultipleRules(t *testing.T) {
	polex := buildPolicyException(
		"security-policy",
		true,
		[]string{"rule-1", "rule-2", "rule-3"},
		ownerInfo{kind: "Deployment", name: "web-app", namespace: "production"},
	)

	assert.Equal(t, []string{"rule-1", "rule-2", "rule-3"}, polex.Spec.Exceptions[0].RuleNames)
}

func Test_generateExceptionName(t *testing.T) {
	tests := []struct {
		name       string
		policy     string
		ownerKind  string
		ownerName  string
		wantPrefix string
	}{
		{
			name:       "short names",
			policy:     "require-labels",
			ownerKind:  "Deployment",
			ownerName:  "my-app",
			wantPrefix: "autogen-exc-require-labels-deployment-my-app",
		},
		{
			name:       "names with uppercase",
			policy:     "MyPolicy",
			ownerKind:  "Deployment",
			ownerName:  "MyApp",
			wantPrefix: "autogen-exc-mypolicy-deployment-myapp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generateExceptionName(tt.policy, tt.ownerKind, tt.ownerName)
			assert.Equal(t, tt.wantPrefix, result)
			assert.LessOrEqual(t, len(result), 253)
		})
	}
}

func Test_generateExceptionName_LongName(t *testing.T) {
	longName := ""
	for i := 0; i < 300; i++ {
		longName += "a"
	}
	result := generateExceptionName(longName, "Deployment", "my-app")
	assert.LessOrEqual(t, len(result), 253)
}

func Test_sanitizeName(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"hello-world", "hello-world"},
		{"Hello-World", "hello-world"},
		{"hello_world", "hello-world"},
		{"hello/world", "hello-world"},
		{"-hello", "xhello"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.want, sanitizeName(tt.input))
		})
	}
}

func Test_namespacesForMatch(t *testing.T) {
	assert.Equal(t, []string{"default"}, namespacesForMatch("default"))
	assert.Nil(t, namespacesForMatch(""))
}
