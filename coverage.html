
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gpol: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kyverno/kyverno/pkg/background/gpol/dynamic_watcher.go (83.4%)</option>
				
				<option value="file1">github.com/kyverno/kyverno/pkg/background/gpol/generate_controller.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gpol

import (
        "context"
        "errors"
        "fmt"
        "sync"

        "github.com/go-logr/logr"
        "github.com/kyverno/kyverno/api/kyverno"
        kyvernov1 "github.com/kyverno/kyverno/api/kyverno/v1"
        kyvernov2 "github.com/kyverno/kyverno/api/kyverno/v2"
        "github.com/kyverno/kyverno/pkg/background/common"
        "github.com/kyverno/kyverno/pkg/client/clientset/versioned"
        "github.com/kyverno/kyverno/pkg/clients/dclient"
        "github.com/kyverno/kyverno/pkg/config"
        reportutils "github.com/kyverno/kyverno/pkg/utils/report"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/restmapper"
        "k8s.io/client-go/tools/cache"
        watchTools "k8s.io/client-go/tools/watch"
)

// Helper functions for creating UpdateRequests
func newGenerateUR(policyName string) *kyvernov2.UpdateRequest <span class="cov8" title="1">{
        return &amp;kyvernov2.UpdateRequest{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: kyvernov2.SchemeGroupVersion.String(),
                        Kind:       "UpdateRequest",
                },
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: "ur-",
                        Namespace:    config.KyvernoNamespace(),
                        Labels:       common.GenerateLabelsSet(policyName),
                },
                Spec: kyvernov2.UpdateRequestSpec{
                        Type:   kyvernov2.Generate,
                        Policy: policyName,
                },
        }
}</span>

func addRuleContext(ur *kyvernov2.UpdateRequest, ruleName string, trigger kyvernov1.ResourceSpec, deleteDownstream, cacheRestore bool) <span class="cov8" title="1">{
        ur.Spec.RuleContext = append(ur.Spec.RuleContext, kyvernov2.RuleContext{
                Rule: ruleName,
                Trigger: kyvernov1.ResourceSpec{
                        Kind:       trigger.GetKind(),
                        Namespace:  trigger.GetNamespace(),
                        Name:       trigger.GetName(),
                        APIVersion: trigger.GetAPIVersion(),
                        UID:        trigger.GetUID(),
                },
                DeleteDownstream: deleteDownstream,
                CacheRestore:     cacheRestore,
        })
}</span>

type Resource struct {
        Name      string
        Namespace string
        Hash      string
        Labels    map[string]string
        Data      *unstructured.Unstructured
}

type WatchManager struct {
        // clients
        client        dclient.Interface
        kyvernoClient versioned.Interface

        // mapper
        restMapper meta.RESTMapper

        // dynamicWatchers references the GVR of the generated resources to the corresponding watcher.
        dynamicWatchers map[schema.GroupVersionResource]*watcher
        // policyRefs maps the policy name to the set of generated resources.
        policyRefs map[string][]schema.GroupVersionResource
        // refCount tracks the number of policies that generates the same resource.
        refCount map[schema.GroupVersionResource]int

        log  logr.Logger
        lock sync.Mutex
}

type watcher struct {
        watcher       watch.Interface
        metadataCache map[types.UID]Resource
}

func NewWatchManager(log logr.Logger, client dclient.Interface, kyvernoClient versioned.Interface) *WatchManager <span class="cov8" title="1">{
        apiGroupResources, _ := restmapper.GetAPIGroupResources(client.GetKubeClient().Discovery())
        restMapper := restmapper.NewDiscoveryRESTMapper(apiGroupResources)
        return &amp;WatchManager{
                log:             log,
                client:          client,
                kyvernoClient:   kyvernoClient,
                restMapper:      restMapper,
                dynamicWatchers: map[schema.GroupVersionResource]*watcher{},
                policyRefs:      map[string][]schema.GroupVersionResource{},
                refCount:        map[schema.GroupVersionResource]int{},
        }
}</span>

func (wm *WatchManager) SyncWatchers(policyName string, generatedResources []*unstructured.Unstructured) error <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()

        logger := wm.log
        newGVRs := make(map[schema.GroupVersionResource]bool)
        // start a new watcher for each generated resource
        for _, resource := range generatedResources </span><span class="cov8" title="1">{
                gvk := resource.GroupVersionKind()
                mapping, err := wm.restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to map gvk to gvr %s (%v)", gvk, err)
                }</span>

                <span class="cov8" title="1">gvr := mapping.Resource
                logger.V(2).Info("processing generated resource", "gvr", gvr, "name", resource.GetName())
                newGVRs[gvr] = true

                // if the watcher for this GVR already exists, skip it
                if wm.dynamicWatchers[gvr] != nil </span><span class="cov8" title="1">{
                        logger.V(2).Info("watcher already exists for GVR", "gvr", gvr)
                        // add the resource to the metadata cache
                        wm.dynamicWatchers[gvr].metadataCache[resource.GetUID()] = Resource{
                                Name:      resource.GetName(),
                                Namespace: resource.GetNamespace(),
                                Labels:    resource.GetLabels(),
                                Hash:      reportutils.CalculateResourceHash(*resource),
                                Data:      resource,
                        }
                        continue</span>
                }

                // start a new watcher for this GVR
                <span class="cov8" title="1">w, err := wm.startWatcher(resource, gvr)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">wm.dynamicWatchers[gvr] = w
                // add the resource to the metadata cache
                wm.dynamicWatchers[gvr].metadataCache[resource.GetUID()] = Resource{
                        Name:      resource.GetName(),
                        Namespace: resource.GetNamespace(),
                        Labels:    resource.GetLabels(),
                        Hash:      reportutils.CalculateResourceHash(*resource),
                        Data:      resource,
                }</span>
        }

        <span class="cov8" title="1">oldGVRs := wm.policyRefs[policyName]
        // update the ref count for the new GVRs
        for gvr := range newGVRs </span><span class="cov8" title="1">{
                found := false
                for _, oldGVR := range oldGVRs </span><span class="cov8" title="1">{
                        if gvr == oldGVR </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        wm.refCount[gvr]++
                }</span>
        }
        // stop old watchers that are not in the new gvr list.
        // it means that the policy no longer generates those resources.
        <span class="cov8" title="1">for _, oldGVR := range oldGVRs </span><span class="cov8" title="1">{
                if _, found := newGVRs[oldGVR]; !found </span><span class="cov8" title="1">{
                        wm.refCount[oldGVR]--
                        // delete the old resources generated by this policy
                        if oldWatcher, exists := wm.dynamicWatchers[oldGVR]; exists </span><span class="cov8" title="1">{
                                var uidsToDelete []types.UID
                                for uid, resource := range oldWatcher.metadataCache </span><span class="cov8" title="1">{
                                        // identify resources managed by this specific policy via a label
                                        if resource.Labels[common.GeneratePolicyLabel] == policyName </span><span class="cov8" title="1">{
                                                uidsToDelete = append(uidsToDelete, uid)
                                        }</span>
                                }

                                <span class="cov8" title="1">for _, uid := range uidsToDelete </span><span class="cov8" title="1">{
                                        res := oldWatcher.metadataCache[uid]
                                        logger.V(4).Info("deleting downstream resource", "kind", res.Data.GetKind(), "name", res.Name, "namespace", res.Namespace)
                                        err := wm.client.DeleteResource(context.TODO(), res.Data.GetAPIVersion(), res.Data.GetKind(), res.Namespace, res.Name, false, metav1.DeleteOptions{})
                                        if err != nil </span><span class="cov8" title="1">{
                                                logger.Error(err, "failed to delete downstream resource", "name", res.Name, "namespace", res.Namespace)
                                        }</span> else<span class="cov8" title="1"> {
                                                logger.V(4).Info("downstream resource deleted", "name", res.Name, "namespace", res.Namespace)
                                                // remove the resource from the metadata cache upon successful deletion
                                                delete(oldWatcher.metadataCache, uid)
                                        }</span>
                                }

                                // stop the watcher if no other policy is using it
                                <span class="cov8" title="1">if wm.refCount[oldGVR] &lt;= 0 </span><span class="cov8" title="1">{
                                        oldWatcher.watcher.Stop()
                                        delete(wm.dynamicWatchers, oldGVR)
                                        delete(wm.refCount, oldGVR)
                                }</span>
                        }
                }
        }
        // update the policyRefs with the new GVRs
        <span class="cov8" title="1">wm.policyRefs[policyName] = make([]schema.GroupVersionResource, 0, len(newGVRs))
        for gvr := range newGVRs </span><span class="cov8" title="1">{
                wm.policyRefs[policyName] = append(wm.policyRefs[policyName], gvr)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetDownstreams retrieves all downstream resources generated by a specific policy.
func (wm *WatchManager) GetDownstreams(policyName string) []*unstructured.Unstructured <span class="cov8" title="1">{
        logger := wm.log.WithValues("policyName", policyName)
        logger.V(4).Info("getting downstream resources for policy")

        var downstreams []*unstructured.Unstructured
        if gvrList, exists := wm.policyRefs[policyName]; exists </span><span class="cov8" title="1">{
                for _, gvr := range gvrList </span><span class="cov8" title="1">{
                        watcher, watcherExists := wm.dynamicWatchers[gvr]
                        if !watcherExists </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, resource := range watcher.metadataCache </span><span class="cov8" title="1">{
                                // identify resources managed by this specific policy via a label
                                if resource.Labels[common.GeneratePolicyLabel] == policyName </span><span class="cov8" title="1">{
                                        logger.V(4).Info("found downstream resource", "kind", resource.Data.GetKind(), "name", resource.Name, "namespace", resource.Namespace)
                                        // create a copy of the resource to avoid modifying the original one
                                        downstream := resource.Data.DeepCopy()
                                        downstreams = append(downstreams, downstream)
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                logger.V(4).Info("no watchers found for policy")
        }</span>
        <span class="cov8" title="1">return downstreams</span>
}

// DeleteDownstreams deletes all downstream resources generated by a policy in the following cases:
// 1. When the trigger resource is deleted.
// 2. When the policy is updated to generate different resources.
// It will not stop the watchers, but will delete the generated resources and remove them from the metadata cache.
func (wm *WatchManager) DeleteDownstreams(policyName string, trigger *kyvernov1.ResourceSpec) <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()

        logger := wm.log.WithValues("policyName", policyName)
        logger.V(2).Info("deleting downstream resources for policy")

        if gvrList, exists := wm.policyRefs[policyName]; exists </span><span class="cov8" title="1">{
                for _, gvr := range gvrList </span><span class="cov8" title="1">{
                        logger := logger.WithValues("gvr", gvr)
                        watcher, watcherExists := wm.dynamicWatchers[gvr]
                        if !watcherExists </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var uidsToDelete []types.UID
                        for uid, resource := range watcher.metadataCache </span><span class="cov8" title="1">{
                                // identify resources managed by this specific policy via a label
                                if resource.Labels[common.GeneratePolicyLabel] == policyName </span><span class="cov8" title="1">{
                                        if trigger == nil || resource.Labels[common.GenerateTriggerUIDLabel] == string(trigger.UID) </span><span class="cov8" title="1">{
                                                uidsToDelete = append(uidsToDelete, uid)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">for _, uid := range uidsToDelete </span><span class="cov8" title="1">{
                                res := watcher.metadataCache[uid]
                                logger.V(4).Info("deleting downstream resource", "kind", res.Data.GetKind(), "name", res.Name, "namespace", res.Namespace)
                                err := wm.client.DeleteResource(context.TODO(), res.Data.GetAPIVersion(), res.Data.GetKind(), res.Namespace, res.Name, false, metav1.DeleteOptions{})
                                if err != nil </span><span class="cov8" title="1">{
                                        logger.Error(err, "failed to delete downstream resource", "name", res.Name, "namespace", res.Namespace)
                                }</span> else<span class="cov8" title="1"> {
                                        logger.V(4).Info("downstream resource deleted", "name", res.Name, "namespace", res.Namespace)
                                        // remove the resource from the metadata cache upon successful deletion
                                        delete(watcher.metadataCache, uid)
                                }</span>
                        }
                }
        }
}

// RemoveWatchersForPolicy removes all downstream resources and watchers for a given policy name.
func (wm *WatchManager) RemoveWatchersForPolicy(policyName string, deleteDownstream bool) <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()

        logger := wm.log.WithValues("policyName", policyName)
        logger.V(2).Info("removing policy resources and watchers")

        if gvrList, exists := wm.policyRefs[policyName]; exists </span><span class="cov8" title="1">{
                for _, gvr := range gvrList </span><span class="cov8" title="1">{
                        logger := logger.WithValues("gvr", gvr)
                        watcher, watcherExists := wm.dynamicWatchers[gvr]
                        if !watcherExists </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var uidsToDelete []types.UID
                        for uid, resource := range watcher.metadataCache </span><span class="cov8" title="1">{
                                // identify resources managed by this specific policy via a label
                                if resource.Labels[common.GeneratePolicyLabel] == policyName </span><span class="cov8" title="1">{
                                        uidsToDelete = append(uidsToDelete, uid)
                                }</span>
                        }

                        <span class="cov8" title="1">for _, uid := range uidsToDelete </span><span class="cov8" title="1">{
                                res := watcher.metadataCache[uid]
                                // delete the downstream if the policy is deleted and it is the only source that generated it.
                                if deleteDownstream </span><span class="cov8" title="1">{
                                        if _, exists := res.Labels[common.GenerateSourceUIDLabel]; !exists </span><span class="cov8" title="1">{
                                                logger.V(4).Info("deleting downstream resource", "kind", res.Data.GetKind(), "name", res.Name, "namespace", res.Namespace)
                                                err := wm.client.DeleteResource(context.TODO(), res.Data.GetAPIVersion(), res.Data.GetKind(), res.Namespace, res.Name, false, metav1.DeleteOptions{})
                                                if err != nil </span><span class="cov0" title="0">{
                                                        logger.Error(err, "failed to delete downstream resource", "name", res.Name, "namespace", res.Namespace)
                                                }</span> else<span class="cov8" title="1"> {
                                                        logger.V(4).Info("downstream resource deleted", "name", res.Name, "namespace", res.Namespace)
                                                }</span>
                                        }
                                }
                                // remove the resource from the metadata cache
                                <span class="cov8" title="1">delete(watcher.metadataCache, uid)</span>
                        }

                        // decrement ref count and stop watcher if no longer needed
                        <span class="cov8" title="1">wm.refCount[gvr]--
                        if wm.refCount[gvr] &lt;= 0 </span><span class="cov8" title="1">{
                                logger.V(3).Info("stopping watcher as it has no more references")
                                watcher.watcher.Stop()
                                delete(wm.dynamicWatchers, gvr)
                                delete(wm.refCount, gvr)
                        }</span>
                }
                // Clean up the policy reference
                <span class="cov8" title="1">delete(wm.policyRefs, policyName)</span>
        } else<span class="cov8" title="1"> {
                logger.V(4).Info("no watchers found for policy")
        }</span>
}

// StopWatchers stops all dynamic watchers and clears the internal state.
func (wm *WatchManager) StopWatchers() <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()
        for _, watcher := range wm.dynamicWatchers </span><span class="cov8" title="1">{
                watcher.watcher.Stop()
        }</span>
        <span class="cov8" title="1">wm.dynamicWatchers = map[schema.GroupVersionResource]*watcher{}
        wm.policyRefs = map[string][]schema.GroupVersionResource{}
        wm.refCount = map[schema.GroupVersionResource]int{}</span>
}

// startWatcher starts a new watcher for the given resource and GVR.
// It initializes the metadata cache and sets up the watch interface.
// The watcher will handle events for the resource and update the metadata cache accordingly.
// It returns a pointer to the watcher or an error if the watcher could not be created.
func (wm *WatchManager) startWatcher(resource *unstructured.Unstructured, gvr schema.GroupVersionResource) (*watcher, error) <span class="cov8" title="1">{
        metadataCache := map[types.UID]Resource{}
        metadataCache[resource.GetUID()] = Resource{
                Name:      resource.GetName(),
                Namespace: resource.GetNamespace(),
                Labels:    resource.GetLabels(),
                Hash:      reportutils.CalculateResourceHash(*resource),
                Data:      resource,
        }
        resourceVersion := resource.GetResourceVersion()
        logger := wm.log.WithValues("resourceVersion", resourceVersion)
        logger.V(2).Info("start watcher ...")
        watchFunc := func(options metav1.ListOptions) (watch.Interface, error) </span><span class="cov8" title="1">{
                logger.V(3).Info("creating watcher...")
                watch, err := wm.client.GetDynamicInterface().Resource(gvr).Watch(context.Background(), options)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to watch")
                }</span>
                <span class="cov8" title="1">return watch, err</span>
        }
        <span class="cov8" title="1">watchInterface, err := watchTools.NewRetryWatcherWithContext(context.TODO(), resourceVersion, &amp;cache.ListWatch{WatchFunc: watchFunc})
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "failed to create watcher")
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                w := &amp;watcher{
                        watcher:       watchInterface,
                        metadataCache: metadataCache,
                }
                go func(gvr schema.GroupVersionResource) </span><span class="cov8" title="1">{
                        defer logger.V(2).Info("watcher stopped")
                        for event := range watchInterface.ResultChan() </span><span class="cov0" title="0">{
                                switch event.Type </span>{
                                case watch.Added:<span class="cov0" title="0">
                                        wm.handleAdd(event.Object.(*unstructured.Unstructured), gvr)</span>
                                case watch.Modified:<span class="cov0" title="0">
                                        wm.handleUpdate(event.Object.(*unstructured.Unstructured), gvr)</span>
                                case watch.Deleted:<span class="cov0" title="0">
                                        wm.handleDelete(event.Object.(*unstructured.Unstructured), gvr)</span>
                                case watch.Error:<span class="cov0" title="0">
                                        logger.Error(errors.New("watch error event received"), "watch error event received", "event", event.Object)</span>
                                }
                        }
                }(gvr)
                <span class="cov8" title="1">return w, nil</span>
        }
}

func (wm *WatchManager) handleAdd(obj *unstructured.Unstructured, gvr schema.GroupVersionResource) <span class="cov8" title="1">{
        wm.log.Info("Resource added", "name", obj.GetName())
}</span>

func (wm *WatchManager) handleUpdate(obj *unstructured.Unstructured, gvr schema.GroupVersionResource) <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()

        wm.log.Info("Resource updated", "name", obj.GetName())
        watcher, exists := wm.dynamicWatchers[gvr]
        if exists </span><span class="cov8" title="1">{
                uid := obj.GetUID()
                // the metadata cache is used to track the generated resources.
                // if the resource is not in the cache, it means it is one of the following:
                // - it is the source resource with sync enabled, and we need to update the downstream resources.
                // - it is the source resource with sync disabled, and we do nothing.
                // - it is the downstream resource with sync disabled, and we do nothing.
                if _, ok := watcher.metadataCache[uid]; !ok </span><span class="cov8" title="1">{
                        source := obj.DeepCopy()
                        // clean up parameters that shouldn't be copied
                        source.SetUID("")
                        source.SetSelfLink("")
                        source.SetCreationTimestamp(metav1.Time{})
                        source.SetManagedFields(nil)
                        source.SetResourceVersion("")
                        // fetch downstreams that have the source UID label.
                        sourceLabel := map[string]string{
                                common.GenerateSourceUIDLabel: string(uid),
                        }
                        selector := &amp;metav1.LabelSelector{MatchLabels: sourceLabel}
                        downstreams, err := wm.client.ListResource(context.TODO(), obj.GetAPIVersion(), obj.GetKind(), "", selector)
                        if err != nil </span><span class="cov0" title="0">{
                                wm.log.Error(err, "failed to list downstream resources")
                        }</span>
                        <span class="cov8" title="1">for _, downstream := range downstreams.Items </span><span class="cov8" title="1">{
                                // if the downstream doesn't exist in the metadata cache, it means sync is disabled.
                                if _, exists := watcher.metadataCache[downstream.GetUID()]; !exists </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // update the downstream resources with the source information.
                                <span class="cov0" title="0">newResource := &amp;unstructured.Unstructured{}
                                newResource.SetUnstructuredContent(source.UnstructuredContent())
                                newResource.SetName(downstream.GetName())
                                newResource.SetNamespace(downstream.GetNamespace())
                                newResource.SetKind(downstream.GetKind())
                                newResource.SetAPIVersion(downstream.GetAPIVersion())
                                newResource.SetLabels(downstream.GetLabels())
                                _, err := wm.client.UpdateResource(context.TODO(), downstream.GetAPIVersion(), downstream.GetKind(), downstream.GetNamespace(), newResource, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        wm.log.Error(err, "failed to update downstream resource", "name", downstream.GetName(), "namespace", downstream.GetNamespace())
                                }</span> else<span class="cov0" title="0"> {
                                        wm.log.V(4).Info("downstream resource updated", "name", downstream.GetName(), "namespace", downstream.GetNamespace())
                                        hash := reportutils.CalculateResourceHash(*newResource)
                                        // update the metadata cache for the downstream resource
                                        watcher.metadataCache[downstream.GetUID()] = Resource{
                                                Name:      downstream.GetName(),
                                                Namespace: downstream.GetNamespace(),
                                                Labels:    downstream.GetLabels(),
                                                Hash:      hash,
                                                Data:      newResource,
                                        }
                                        wm.log.V(4).Info("resource metadata updated", "name", downstream.GetName(), "namespace", downstream.GetNamespace(), "hash", hash)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // if the resource is already in the cache, then it is the downstream resource that has been updated and it is sync enabled.
                        hash := reportutils.CalculateResourceHash(*obj)
                        // if the hash of the resource is different from the one in the cache
                        // then we need to revert the downstream resource as it means that it has been updated by the user.
                        if hash != watcher.metadataCache[uid].Hash </span><span class="cov8" title="1">{
                                wm.log.V(4).Info("downstream resource updated by user, reverting changes", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                downstream := watcher.metadataCache[uid].Data
                                // clean up parameters that shouldn't be copied
                                downstream.SetUID("")
                                downstream.SetSelfLink("")
                                downstream.SetCreationTimestamp(metav1.Time{})
                                downstream.SetManagedFields(nil)
                                downstream.SetResourceVersion("")
                                _, err := wm.client.UpdateResource(context.TODO(), downstream.GetAPIVersion(), downstream.GetKind(), downstream.GetNamespace(), downstream, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        wm.log.Error(err, "failed to revert downstream resource", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                }</span> else<span class="cov8" title="1"> {
                                        wm.log.V(4).Info("downstream resource reverted", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                }</span>
                        }
                }
        }
}

func (wm *WatchManager) handleDelete(obj *unstructured.Unstructured, gvr schema.GroupVersionResource) <span class="cov8" title="1">{
        wm.lock.Lock()
        defer wm.lock.Unlock()

        wm.log.Info("Resource deleted", "name", obj.GetName())
        watcher, exists := wm.dynamicWatchers[gvr]
        if exists </span><span class="cov8" title="1">{
                uid := obj.GetUID()
                labels := obj.GetLabels()
                managedBy := labels[kyverno.LabelAppManagedBy] == kyverno.ValueKyvernoApp
                // the source resource is deleted, we need to clean up the downstream resources.
                if !managedBy </span><span class="cov0" title="0">{
                        wm.log.V(4).Info("source resource deleted, removing downstreams", "name", obj.GetName(), "namespace", obj.GetNamespace())
                        // fetch downstreams that have the source UID label.
                        sourceLabel := map[string]string{
                                common.GenerateSourceUIDLabel: string(uid),
                        }
                        selector := &amp;metav1.LabelSelector{MatchLabels: sourceLabel}
                        downstreams, err := wm.client.ListResource(context.TODO(), obj.GetAPIVersion(), obj.GetKind(), "", selector)
                        if err != nil </span><span class="cov0" title="0">{
                                wm.log.Error(err, "failed to list downstream resources")
                        }</span> else<span class="cov0" title="0"> {
                                for _, downstream := range downstreams.Items </span><span class="cov0" title="0">{
                                        // if the downstream doesn't exist in the metadata cache, it means sync is disabled.
                                        if _, exists := watcher.metadataCache[downstream.GetUID()]; !exists </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">err := wm.client.DeleteResource(context.TODO(), downstream.GetAPIVersion(), downstream.GetKind(), downstream.GetNamespace(), downstream.GetName(), false, metav1.DeleteOptions{})
                                        if err != nil </span><span class="cov0" title="0">{
                                                wm.log.Error(err, "failed to delete downstream resource", "name", downstream.GetName(), "namespace", downstream.GetNamespace())
                                        }</span> else<span class="cov0" title="0"> {
                                                wm.log.V(4).Info("downstream resource deleted", "name", downstream.GetName(), "namespace", downstream.GetNamespace())
                                        }</span>
                                        // remove the resource from the metadata cache
                                        <span class="cov0" title="0">delete(watcher.metadataCache, downstream.GetUID())</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        if resource, ok := watcher.metadataCache[uid]; ok </span><span class="cov8" title="1">{
                                wm.log.V(4).Info("downstream resource deleted", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                // if the resource is already in the cache, then it is the downstream resource that has been deleted by the user.
                                // Instead of directly recreating, create an UpdateRequest to trigger proper re-evaluation including preconditions.
                                
                                // Extract policy and rule information from labels
                                labels := resource.Labels
                                if labels == nil </span><span class="cov0" title="0">{
                                        wm.log.V(4).Info("no labels found on deleted resource, skipping UpdateRequest creation")
                                        return
                                }</span>
                                
                                <span class="cov8" title="1">policyName := labels[common.GeneratePolicyLabel]
                                ruleName := labels[common.GenerateRuleLabel]
                                sourceUID := labels[common.GenerateSourceUIDLabel]
                                
                                if policyName == "" || ruleName == "" || sourceUID == "" </span><span class="cov8" title="1">{
                                        wm.log.V(4).Info("missing required labels on deleted resource, falling back to direct recreation",
                                                "policyName", policyName, "ruleName", ruleName, "sourceUID", sourceUID)
                                        // Fallback to old behavior if labels are missing
                                        downstream := resource.Data.DeepCopy()
                                        downstream.SetUID("")
                                        downstream.SetSelfLink("")
                                        downstream.SetCreationTimestamp(metav1.Time{})
                                        downstream.SetManagedFields(nil)
                                        downstream.SetResourceVersion("")
                                        _, err := wm.client.CreateResource(context.TODO(), downstream.GetAPIVersion(), downstream.GetKind(), downstream.GetNamespace(), downstream, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                wm.log.Error(err, "failed to revert downstream resource", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                        }</span> else<span class="cov8" title="1"> {
                                                wm.log.V(4).Info("downstream resource reverted", "name", obj.GetName(), "namespace", obj.GetNamespace())
                                        }</span>
                                        <span class="cov8" title="1">return</span>
                                }
                                
                                // Get source/trigger resource to create the UpdateRequest
                                <span class="cov8" title="1">sourceObj, err := wm.client.GetResource(context.TODO(), "", "Namespace", "", resource.Namespace)
                                if err != nil </span><span class="cov0" title="0">{
                                        wm.log.Error(err, "failed to get source resource for UpdateRequest", "namespace", resource.Namespace)
                                        return
                                }</span>
                                
                                // Create UpdateRequest to trigger proper re-evaluation
                                <span class="cov8" title="1">ur := newGenerateUR(policyName)
                                triggerSpec := common.ResourceSpecFromUnstructured(*sourceObj)
                                addRuleContext(ur, ruleName, triggerSpec, false, false)
                                
                                // Create the UpdateRequest
                                created, err := wm.kyvernoClient.KyvernoV2().UpdateRequests(config.KyvernoNamespace()).Create(context.TODO(), ur, metav1.CreateOptions{})
                                if err != nil </span><span class="cov0" title="0">{
                                        wm.log.Error(err, "failed to create UpdateRequest for deleted resource re-evaluation")
                                        return
                                }</span>
                                
                                // Set the UpdateRequest to Pending state so it gets processed
                                <span class="cov8" title="1">created.Status.State = kyvernov2.Pending
                                _, err = wm.kyvernoClient.KyvernoV2().UpdateRequests(config.KyvernoNamespace()).UpdateStatus(context.TODO(), created, metav1.UpdateOptions{})
                                if err != nil </span><span class="cov0" title="0">{
                                        wm.log.Error(err, "failed to update UpdateRequest status to Pending")
                                }</span> else<span class="cov8" title="1"> {
                                        wm.log.V(4).Info("created UpdateRequest for deleted resource re-evaluation", "ur", created.Name, "policy", policyName, "rule", ruleName)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gpol

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        kyvernov1 "github.com/kyverno/kyverno/api/kyverno/v1"
        kyvernov2 "github.com/kyverno/kyverno/api/kyverno/v2"
        "github.com/kyverno/kyverno/pkg/background/common"
        "github.com/kyverno/kyverno/pkg/breaker"
        celengine "github.com/kyverno/kyverno/pkg/cel/engine"
        "github.com/kyverno/kyverno/pkg/cel/libs"
        gpolengine "github.com/kyverno/kyverno/pkg/cel/policies/gpol/engine"
        "github.com/kyverno/kyverno/pkg/client/clientset/versioned"
        "github.com/kyverno/kyverno/pkg/clients/dclient"
        engineapi "github.com/kyverno/kyverno/pkg/engine/api"
        reportutils "github.com/kyverno/kyverno/pkg/utils/report"
        "go.uber.org/multierr"
        admissionv1 "k8s.io/api/admission/v1"
        authenticationv1 "k8s.io/api/authentication/v1"
        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/client-go/restmapper"
)

// CELGenerateController is used to process URs that are generated as a result of an event from the trigger resource.
type CELGenerateController struct {
        // clients
        client        dclient.Interface
        kyvernoClient versioned.Interface

        // mapper
        restMapper meta.RESTMapper

        context      libs.Context
        engine       gpolengine.Engine
        provider     gpolengine.Provider
        watchManager *WatchManager

        statusControl common.StatusControlInterface

        reportsConfig reportutils.ReportingConfiguration
        breaker.Breaker

        log logr.Logger
}

// NewCELGenerateController creates a new CELGenerateController.
func NewCELGenerateController(
        client dclient.Interface,
        kyvernoClient versioned.Interface,
        context libs.Context,
        engine gpolengine.Engine,
        provider gpolengine.Provider,
        watchManager *WatchManager,
        statusControl common.StatusControlInterface,
        reportsConfig reportutils.ReportingConfiguration,
        log logr.Logger,
) *CELGenerateController <span class="cov0" title="0">{
        apiGroupResources, _ := restmapper.GetAPIGroupResources(client.GetKubeClient().Discovery())
        restMapper := restmapper.NewDiscoveryRESTMapper(apiGroupResources)
        return &amp;CELGenerateController{
                client:        client,
                kyvernoClient: kyvernoClient,
                restMapper:    restMapper,
                context:       context,
                engine:        engine,
                provider:      provider,
                watchManager:  watchManager,
                statusControl: statusControl,
                reportsConfig: reportsConfig,
                log:           log,
        }
}</span>

func (c *CELGenerateController) ProcessUR(ur *kyvernov2.UpdateRequest) error <span class="cov0" title="0">{
        logger := c.log.WithValues("name", ur.GetName(), "policy", ur.Spec.GetPolicyKey())
        generatedResources := make([]kyvernov1.ResourceSpec, 0)
        logger.V(2).Info("start processing UR", "ur", ur.Name, "resourceVersion", ur.GetResourceVersion())

        var failures []error
        for i := 0; i &lt; len(ur.Spec.RuleContext); i++ </span><span class="cov0" title="0">{
                if ur.Spec.RuleContext[i].DeleteDownstream </span><span class="cov0" title="0">{
                        c.watchManager.DeleteDownstreams(ur.Spec.GetPolicyKey(), &amp;ur.Spec.RuleContext[i].Trigger)
                        continue</span>
                }
                <span class="cov0" title="0">trigger, err := common.GetTrigger(c.client, ur.Spec, i, c.log)
                if err != nil || trigger == nil </span><span class="cov0" title="0">{
                        logger.V(4).Info("the trigger resource does not exist or is pending creation")
                        failures = append(failures, fmt.Errorf("gpol %s failed: failed to fetch trigger resource: %v", ur.Spec.GetPolicyKey(), err))
                        continue</span>
                }
                <span class="cov0" title="0">var request celengine.EngineRequest
                admissionRequest := ur.Spec.Context.AdmissionRequestInfo.AdmissionRequest
                if admissionRequest == nil </span><span class="cov0" title="0">{
                        gvk := trigger.GroupVersionKind()
                        mapping, err := c.restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to map gvk to gvr %s (%v)", gvk, err)
                        }</span>

                        <span class="cov0" title="0">gvr := mapping.Resource
                        request = celengine.Request(
                                c.context,
                                trigger.GroupVersionKind(),
                                gvr,
                                "",
                                trigger.GetName(),
                                trigger.GetNamespace(),
                                admissionv1.Create,
                                authenticationv1.UserInfo{},
                                trigger,
                                nil,
                                false,
                                nil,
                        )</span>
                } else<span class="cov0" title="0"> {
                        request = celengine.RequestFromAdmission(c.context, *admissionRequest)
                }</span>
                <span class="cov0" title="0">policy, err := c.provider.Get(context.TODO(), ur.Spec.GetPolicyKey())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to fetch gpol", "gpol", ur.Spec.GetPolicyKey())
                        failures = append(failures, fmt.Errorf("gpol %s failed: %v", ur.Spec.GetPolicyKey(), err))
                        continue</span>
                }
                <span class="cov0" title="0">isSync := policy.Policy.Spec.SynchronizationEnabled()
                gpolResponse, err := c.engine.Handle(request, policy, ur.Spec.RuleContext[i].CacheRestore)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to generate resources for gpol", "gpol", ur.Spec.GetPolicyKey())
                        failures = append(failures, fmt.Errorf("gpol %s failed: %v", ur.Spec.GetPolicyKey(), err))
                }</span>
                <span class="cov0" title="0">engineResponse := engineapi.EngineResponse{
                        Resource:       *gpolResponse.Trigger,
                        PolicyResponse: engineapi.PolicyResponse{},
                }
                for _, res := range gpolResponse.Policies </span><span class="cov0" title="0">{
                        if res.Result == nil </span><span class="cov0" title="0">{
                                logger.V(4).Info("no resources generated by gpol", "gpol", ur.Spec.GetPolicyKey(), "policy", res.Policy.GetName())
                                continue</span>
                        }
                        <span class="cov0" title="0">engineResponse.PolicyResponse.Rules = []engineapi.RuleResponse{*res.Result}
                        engineResponse = engineResponse.WithPolicy(engineapi.NewGeneratingPolicy(&amp;res.Policy))
                        if res.Result.Status() == engineapi.RuleStatusSkip </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, resource := range res.Result.GeneratedResources() </span><span class="cov0" title="0">{
                                generatedResources = append(generatedResources, kyvernov1.ResourceSpec{
                                        Kind:       resource.GetKind(),
                                        APIVersion: resource.GetAPIVersion(),
                                        Name:       resource.GetName(),
                                        Namespace:  resource.GetNamespace(),
                                })
                        }</span>
                        <span class="cov0" title="0">if isSync </span><span class="cov0" title="0">{
                                go func() </span><span class="cov0" title="0">{
                                        if err := c.watchManager.SyncWatchers(ur.Spec.GetPolicyKey(), res.Result.GeneratedResources()); err != nil </span><span class="cov0" title="0">{
                                                logger.Error(err, "failed to sync watchers for generated resources", "gpol", ur.Spec.GetPolicyKey())
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.V(4).Info("synced watchers for generated resources", "gpol", ur.Spec.GetPolicyKey(), "resources", res.Result.GeneratedResources())
                                        }</span>
                                }()
                        }
                }
                // generate reports if enabled
                <span class="cov0" title="0">if c.reportsConfig.GenerateReportsEnabled() &amp;&amp; len(engineResponse.PolicyResponse.Rules) &gt; 0 </span><span class="cov0" title="0">{
                        if err := c.createReports(context.TODO(), *trigger, engineResponse); err != nil </span><span class="cov0" title="0">{
                                c.log.Error(err, "failed to create report")
                        }</span>
                }
        }
        <span class="cov0" title="0">return updateURStatus(c.statusControl, *ur, multierr.Combine(failures...), generatedResources)</span>
}

func (c *CELGenerateController) createReports(
        ctx context.Context,
        resource unstructured.Unstructured,
        engineResponses ...engineapi.EngineResponse,
) error <span class="cov0" title="0">{
        report := reportutils.BuildGenerateReport(resource.GetNamespace(), resource.GroupVersionKind(), resource.GetName(), resource.GetUID(), engineResponses...)
        if len(report.GetResults()) &gt; 0 </span><span class="cov0" title="0">{
                err := breaker.GetReportsBreaker().Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                        _, err := reportutils.CreateEphemeralReport(ctx, report, c.kyvernoClient)
                        return err
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func updateURStatus(statusControl common.StatusControlInterface, ur kyvernov2.UpdateRequest, err error, genResources []kyvernov1.ResourceSpec) error <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                if _, err := statusControl.Failed(ur.GetName(), err.Error(), genResources); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if _, err := statusControl.Success(ur.GetName(), genResources); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
